---
title: "[대용량 트래픽 쿠폰 시스템 #1] 낙관적 락 적용기"
date: 2024-01-15
categories: [Spring, JPA, 동시성]
tags: [spring-boot, jpa, optimistic-lock, concurrency, version]
published: false
---

# 대용량 트래픽 쿠폰 시스템 #1 - 낙관적 락 적용기

## 1. 낙관적 락이란?

### 1.1 개념

낙관적 락(Optimistic Lock)은 **"충돌이 거의 없을 것"**이라고 낙관적으로 가정하는 방식이다. 데이터를 읽을 때는 락을 걸지 않고, 수정할 때 다른 사람이 먼저 수정했는지 확인한다.

동작 방식:
1. 데이터 조회 시 `version` 값을 함께 가져온다
2. 데이터 수정 시 `WHERE version = ?` 조건으로 UPDATE
3. version이 바뀌어 있으면 UPDATE 실패 → 예외 발생 → 재시도

### 1.2 비관적 락과 비교

| 구분 | 낙관적 락 | 비관적 락 |
|------|-----------|-----------|
| 가정 | 충돌 거의 없음 | 충돌 자주 발생 |
| 락 시점 | UPDATE 시 검증 | SELECT 시 락 획득 |
| 동시성 | 높음 (락 없이 조회) | 낮음 (락 대기 발생) |
| 충돌 처리 | 애플리케이션에서 재시도 | DB에서 순차 처리 |
| 적합 상황 | 읽기 많고 쓰기 적음 | 쓰기 많고 충돌 잦음 |

### 1.3 왜 낙관적 락을 먼저 선택했나?

선착순 쿠폰 발급은 "읽기(조회) 후 쓰기(발급)"가 순간적으로 몰리는 상황이다. 비관적 락은 조회 시점부터 락을 잡아서 대기 시간이 길어질 수 있다. 낙관적 락은 일단 조회를 빠르게 하고, 충돌 시에만 재시도하니까 **처리량(throughput)이 더 높을 것**이라 기대했다.

결과적으로 문제가 발생했는데, 이건 뒤에서 다룬다.

---

## 2. 구현 내용

### 2.1 전체 흐름

```
클라이언트 요청
    │
    ▼
CouponIssueController
    │
    ▼
CouponIssueService (재시도 로직)
    │  └─ 낙관적 락 충돌 시 최대 3회 재시도
    ▼
CouponIssueTransactionalService (트랜잭션)
    │  ├─ 회원 검증
    │  ├─ 쿠폰 조회 (@Lock + @Version)
    │  ├─ 중복 발급 체크
    │  ├─ 재고 차감 (issuedQuantity++)
    │  └─ 발급 이력 저장
    ▼
DB 커밋 (version 검증)
    │
    ├─ 성공 → 응답 반환
    └─ 실패 (version 불일치) → OptimisticLockException → 재시도
```

### 2.2 적용 위치

| 위치 | 적용 내용 |
|------|-----------|
| `Coupon.java` | `@Version` 필드 추가 |
| `CouponRepository.java` | `@Lock(OPTIMISTIC)` 쿼리 |
| `CouponIssueService.java` | 재시도 로직 + 지수 백오프 |
| `CouponIssueTransactionalService.java` | 트랜잭션 분리 |

---

## 3. 핵심 코드 설명

### 3.1 Coupon 엔티티 - @Version

```java
@Entity
@Table(name = "coupons")
public class Coupon {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Integer totalQuantity;
    private Integer issuedQuantity;

    @Version
    private Long version;  // 낙관적 락 버전

    public void increaseIssuedQuantity() {
        if (!isIssuable()) {
            throw new IllegalStateException("쿠폰 발급이 불가능한 상태입니다.");
        }
        this.issuedQuantity++;
        this.updatedAt = LocalDateTime.now();
    }
}
```

**`@Version`의 동작:**
- JPA가 UPDATE 시 자동으로 `version = version + 1` 처리
- `WHERE id = ? AND version = ?` 조건이 추가됨
- 다른 트랜잭션이 먼저 커밋했으면 WHERE 조건 불일치 → 영향받은 row = 0 → 예외 발생

### 3.2 CouponRepository - @Lock

```java
public interface CouponRepository extends JpaRepository<Coupon, Long> {

    @Lock(LockModeType.OPTIMISTIC)
    @Query("SELECT c FROM Coupon c WHERE c.couponCode = :couponCode")
    Optional<Coupon> findByCouponCodeWithLock(@Param("couponCode") String couponCode);
}
```

**`@Lock(LockModeType.OPTIMISTIC)`:**
- 조회 시점에 version을 읽어온다
- 엔티티 수정 후 flush 시점에 version을 비교한다
- `OPTIMISTIC_FORCE_INCREMENT`를 쓰면 읽기만 해도 version이 증가하는데, 여기선 불필요

### 3.3 CouponIssueService - 재시도 로직

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class CouponIssueService {

    private static final int MAX_RETRY_COUNT = 3;
    private final CouponIssueTransactionalService transactionalService;

    public CouponIssueResponse issueCoupon(String couponCode, Long memberId) {
        int retryCount = 0;

        while (retryCount < MAX_RETRY_COUNT) {
            try {
                return transactionalService.issueCouponWithTransaction(couponCode, memberId);
            } catch (ObjectOptimisticLockingFailureException e) {
                retryCount++;
                log.warn("낙관적 락 충돌 발생. 재시도 {}/{}", retryCount, MAX_RETRY_COUNT);

                if (retryCount >= MAX_RETRY_COUNT) {
                    throw new BusinessException(ErrorCode.COUPON_ISSUE_FAILED);
                }

                // 지수 백오프: 20ms, 40ms, 80ms
                try {
                    Thread.sleep((long) Math.pow(2, retryCount) * 10);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new BusinessException(ErrorCode.COUPON_ISSUE_FAILED);
                }
            }
        }
        throw new BusinessException(ErrorCode.COUPON_ISSUE_FAILED);
    }
}
```

**지수 백오프(Exponential Backoff):**

충돌 후 즉시 재시도하면 또 충돌할 확률이 높다. 대기 시간을 점점 늘려서 충돌 확률을 낮춘다.

| 재시도 | 대기 시간 | 계산 |
|--------|-----------|------|
| 1회차 | 20ms | 2^1 × 10 |
| 2회차 | 40ms | 2^2 × 10 |
| 3회차 | 80ms | 2^3 × 10 |

### 3.4 서비스 분리 - Self-Invocation 문제

처음에는 하나의 서비스에서 재시도 + 트랜잭션을 모두 구현하려 했다.

```java
// ❌ 문제 코드
@Service
public class CouponIssueService {

    public CouponIssueResponse issueCoupon(...) {
        try {
            return this.doIssue(...);  // 같은 클래스 내부 호출
        } catch (OptimisticLockException e) {
            // 재시도
        }
    }

    @Transactional
    public CouponIssueResponse doIssue(...) {
        // 비즈니스 로직
    }
}
```

**문제:** `this.doIssue()` 호출은 프록시를 거치지 않아서 `@Transactional`이 동작하지 않는다.

**원인:** Spring의 `@Transactional`은 AOP 기반 프록시로 동작한다. 외부에서 호출해야 프록시가 끼어들 수 있는데, 같은 클래스 내부에서 호출하면 프록시를 우회한다.

**해결:** 트랜잭션 로직을 별도 클래스로 분리했다.

```java
// ✅ 해결: 서비스 분리
@Service
public class CouponIssueService {
    private final CouponIssueTransactionalService transactionalService;

    public CouponIssueResponse issueCoupon(...) {
        try {
            return transactionalService.issueCouponWithTransaction(...);  // 외부 호출
        } catch (OptimisticLockException e) {
            // 재시도
        }
    }
}

@Service
public class CouponIssueTransactionalService {

    @Transactional
    public CouponIssueResponse issueCouponWithTransaction(...) {
        // 비즈니스 로직
    }
}
```

| 서비스 | 책임 | @Transactional |
|--------|------|----------------|
| CouponIssueService | 재시도 로직, 예외 변환 | 없음 |
| CouponIssueTransactionalService | 비즈니스 로직, DB 작업 | 있음 |

### 3.5 CouponIssueTransactionalService - 비즈니스 로직

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class CouponIssueTransactionalService {

    private static final int COUPON_EXPIRE_DAYS = 30;

    private final CouponRepository couponRepository;
    private final CouponIssueRepository couponIssueRepository;
    private final MemberRepository memberRepository;

    @Transactional
    public CouponIssueResponse issueCouponWithTransaction(String couponCode, Long memberId) {
        // 1. 회원 검증
        Member member = memberRepository.findByIdAndStatus(memberId, MemberStatus.ACTIVE)
                .orElseThrow(() -> new BusinessException(ErrorCode.MEMBER_NOT_FOUND));

        // 2. 쿠폰 조회 (낙관적 락)
        Coupon coupon = couponRepository.findByCouponCodeWithLock(couponCode)
                .orElseThrow(() -> new BusinessException(ErrorCode.COUPON_NOT_FOUND));

        // 3. 중복 발급 체크
        if (couponIssueRepository.existsByCouponIdAndMemberId(coupon.getId(), memberId)) {
            throw new BusinessException(ErrorCode.COUPON_ALREADY_ISSUED);
        }

        // 4. 발급 가능 여부 검증
        if (!coupon.isIssuable()) {
            throw new BusinessException(ErrorCode.COUPON_SOLD_OUT);
        }

        // 5. 재고 차감 (version 증가)
        coupon.increaseIssuedQuantity();

        // 6. 발급 이력 저장
        CouponIssue couponIssue = CouponIssue.builder()
                .couponId(coupon.getId())
                .memberId(memberId)
                .expireDays(COUPON_EXPIRE_DAYS)
                .build();

        couponIssueRepository.save(couponIssue);

        return CouponIssueResponse.from(couponIssue, coupon);
    }
}
```

**처리 순서가 중요한 이유:**

1. 회원 검증을 먼저 → 존재하지 않는 회원이면 불필요한 락 조회 방지
2. 쿠폰 조회 (락) → 여기서 version을 읽어옴
3. 중복 발급 체크 → UK 제약조건 전에 애플리케이션에서 먼저 체크
4. 재고 차감 → version이 증가됨
5. 트랜잭션 커밋 시 version 검증 → 충돌 시 예외 발생

---

## 4. 부하 테스트 결과

### 4.1 테스트 환경

| 항목 | 값 |
|------|-----|
| 동시 사용자 | 500명 |
| 사용자당 요청 | 1회 |
| 쿠폰 수량 | 1,000개 |
| DB | MySQL 8.0 (InnoDB) |
| Connection Pool | HikariCP (max: 50) |

### 4.2 테스트 결과

<!-- 여기에 k6 테스트 결과 이미지 삽입 -->

```
// 테스트 결과 요약
- 총 요청: 500
- 성공: ???
- 실패: ???
- 평균 응답시간: ???ms
- 최대 응답시간: ???ms
```

### 4.3 발견된 문제

테스트 중 예상치 못한 에러가 발생했다.

```
com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException:
Deadlock found when trying to get lock; try restarting transaction
```

**낙관적 락을 사용했는데 왜 Deadlock이?** 🤔

---

## 5. 문제 분석

### 5.1 Deadlock 발생 원인

낙관적 락은 **애플리케이션 레벨**의 동시성 제어다. `@Version`은 UPDATE 시점에만 검증하고, 그 사이에 발생하는 **DB 레벨의 락 경합**은 방지하지 못한다.

### 5.2 Gap Lock + Insert 충돌

InnoDB는 `REPEATABLE READ` 격리 수준에서 **Gap Lock**을 사용한다. 여러 트랜잭션이 동시에 같은 범위를 조회하고 INSERT하면 데드락이 발생할 수 있다.

```
TX A: SELECT ... WHERE coupon_code = 'WELCOME2024' (Gap Lock 획득)
TX B: SELECT ... WHERE coupon_code = 'WELCOME2024' (Gap Lock 획득)
TX A: INSERT INTO coupon_issues ... (B의 Gap Lock 대기)
TX B: INSERT INTO coupon_issues ... (A의 Gap Lock 대기)
→ Deadlock!
```

### 5.3 Unique Index와 Insert

`coupon_issues` 테이블에는 `UK(coupon_id, member_id)` 제약조건이 있다. INSERT 시 유니크 인덱스 검증을 위해 잠금이 발생하고, 이것도 데드락의 원인이 된다.

### 5.4 정리: 낙관적 락의 한계

| 기대 | 현실 |
|------|------|
| version만 검증하면 됨 | DB 레벨에서 다른 락이 발생 |
| 충돌 시 깔끔하게 재시도 | Deadlock으로 트랜잭션 롤백 |
| 높은 처리량 | Gap Lock 경합으로 성능 저하 |

**결론:** 낙관적 락은 **UPDATE 충돌**만 감지한다. 같은 트랜잭션 내에서 발생하는 **INSERT의 락 경합**은 별개 문제다. 동시 트래픽이 높은 상황에서는 낙관적 락만으로 부족하다.

---

## 6. 느낀점 및 다음 단계

### 6.1 이번 Phase에서 배운 것

**JPA 낙관적 락**
- `@Version`과 `@Lock(OPTIMISTIC)`의 동작 원리
- 낙관적 락은 DB 락이 아닌 애플리케이션 레벨 검증

**Spring 트랜잭션**
- Self-Invocation 문제와 프록시 동작 원리
- 트랜잭션 경계와 서비스 분리의 필요성

**동시성의 어려움**
- 이론과 실제는 다르다
- 테스트 없이는 문제를 발견할 수 없다
- 낙관적 락이 "만능"이 아니다

### 6.2 다음 단계: Phase 2 - 비관적 락

낙관적 락의 한계를 확인했다. 다음에는 **비관적 락(Pessimistic Lock)**을 적용해본다.

**다룰 내용:**
- `@Lock(PESSIMISTIC_WRITE)` 적용
- `SELECT ... FOR UPDATE`의 동작 원리
- 낙관적 락과 성능 비교
- Deadlock이 해결되는가?

👉 [다음 글: Phase 2 - 비관적 락 적용기](/posts/high-traffic-coupon-phase2)